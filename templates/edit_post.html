<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Edit: {{ title }}</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/favicon-192x192.png">

    <link rel="stylesheet" href="/static/styles.css">
    <link rel="stylesheet" href="/static/bootstrap.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css">
    <link rel="stylesheet" href="/static/post-content-style.css">
    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 50px); /* Saveボタン(50px)分を引いた高さ */
        }
        textarea {
            font-size: 16px; /* フォントサイズを16px以上に設定 */
            flex-grow: 1; /* 残りのスペースを占める */
            width: 100%; /* 横幅を100%に設定 */
            margin-bottom: 0; /* 余白をなくす */
        }
        /* Saveボタンを画面下部に固定 */
        input[type="submit"] {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            padding: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
        }
        .fixed-bottom-btn {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
        }
        .btn-toolbar {
            display: flex;
            flex-wrap: wrap; /* 自動折り返し */
            gap: 4px;
        }
        .btn-toolbar .btn-group {
            margin-right: 8px; /* グループ間の余白 */
        }
        /* グループ化の視覚的な区切り */
        .btn-group {
            border-right: 2px solid #dee2e6;
            padding-right: 8px;
            margin-right: 8px;
        }
        .btn-group:last-child {
            border-right: none;
        }
        /* スマホ対応 - 横スクロール1行 */
        @media (max-width: 768px) {
            .btn-toolbar {
                flex-wrap: nowrap; /* 折り返しなし */
                overflow-x: auto; /* 横スクロール有効 */
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch; /* iOS でスムーズスクロール */
                gap: 2px; /* 隙間を狭く */
                padding-bottom: 4px;
                scrollbar-width: none; /* Firefox: スクロールバー非表示 */
            }
            .btn-toolbar::-webkit-scrollbar {
                display: none; /* Webkit系: スクロールバー非表示 */
            }

            /* よく使うボタンを左側に固定表示 */
            .btn-toolbar > .btn-primary {    /* 挿入、LINE、AI、閲覧、プレビュー（プレビューはスマホでは非表示） */
                position: sticky;
                left: 0;
                z-index: 2;
                background: #0d6efd;
                box-shadow: 2px 0 4px rgba(0,0,0,0.1); /* 固定されていることを示す影 */
            }

            /* グループの区切り線をスマホでは非表示 */
            .btn-group {
                border-right: none;
                padding-right: 4px;
                margin-right: 4px;
            }

            /* ボタンサイズを調整 */
            .btn-toolbar .btn,
            .btn-toolbar .btn-group .btn {
                min-height: 44px; /* タッチ領域確保 */
                white-space: nowrap; /* テキストの折り返しを防ぐ */
            }

            .btn-sm {
                font-size: 0.8rem;
                padding: 0.25rem 0.5rem;
            }

            /* スクロールヒント（右端のグラデーション） */
            .btn-toolbar::after {
                content: '';
                position: sticky;
                right: 0;
                width: 30px;
                height: 100%;
                background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,0.9));
                pointer-events: none;
                flex-shrink: 0;
            }
        }
        .form-control{
            margin-bottom: 5px;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .dialog {
            background: white;
            padding: 20px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%; /* 画面の幅いっぱいに広げる */
        }
        .view-link {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        /* AIモーダル用のスタイル */
        #aiOverlay {
            z-index: 3000;
        }
        #aiOverlay .dialog {
            max-width: 600px;
            width: 90%;
        }
        .ai-context-preview {
            max-height: 100px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.85em;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            #aiOverlay .dialog {
                width: 95%;
                padding: 15px;
            }
            #aiPromptInput {
                font-size: 16px; /* iOS zoom prevention */
            }
            #templateSelect {
                font-size: 16px; /* iOS zoom prevention */
            }
        }

        /* プレビュー機能: PC専用（768px以上） */
        @media (min-width: 769px) {
            /* コンテナ */
            .editor-container {
                display: flex;
                gap: 0;
                flex: 1; /* 残りのスペースを占める */
            }

            /* 編集エリア */
            .editor-pane {
                flex: 1;
                min-width: 200px;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .editor-pane textarea {
                flex: 1;
                resize: none;
            }

            /* リサイザー（ドラッグハンドル） */
            .resizer {
                width: 8px;
                background: #dee2e6;
                cursor: col-resize;
                user-select: none;
                flex-shrink: 0;
                position: relative;
            }

            .resizer:hover {
                background: #0d6efd;
            }

            /* リサイザーの視覚的ヒント */
            .resizer::before {
                content: '';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 3px;
                height: 30px;
                background: repeating-linear-gradient(
                    to bottom,
                    #fff 0px,
                    #fff 2px,
                    transparent 2px,
                    transparent 6px
                );
            }

            /* プレビューエリア */
            .preview-pane {
                flex: 1;
                min-width: 200px;
                padding: 20px;
                background: #f8f9fa;
                overflow-y: auto;
                border-left: 1px solid #dee2e6;
            }

            .preview-pane.hidden {
                display: none;
            }

            /* プレビューが非表示の時は編集エリアが全幅 */
            .editor-container.preview-hidden .editor-pane {
                flex: 1 1 100%;
            }

            .editor-container.preview-hidden .resizer,
            .editor-container.preview-hidden .preview-pane {
                display: none;
            }

            /* プレビュートグルボタン */
            .preview-toggle {
                display: inline-block;
            }

            /* プレビューペイン内の .main-content スタイル調整 */
            .preview-pane.main-content {
                /* height: auto を削除 - 親の flex: 1 と overflow-y: auto に従う */
                width: 100%;
                padding: 20px;
            }

            /* #preview-content のスタイルは /static/styles.css で定義されています */
        }

        /* スマホ（768px未満）: プレビュー機能を完全無効化 */
        @media (max-width: 768px) {
            .resizer,
            .preview-pane,
            .preview-toggle {
                display: none !important;
            }

            .editor-container {
                display: flex; /* flexコンテナにする */
                flex-direction: column;
                flex: 1; /* 残りのスペースを占める */
            }

            .editor-pane {
                display: flex; /* flexコンテナにする */
                flex-direction: column;
                flex: 1; /* 残りのスペースを占める */
            }

            .editor-pane textarea {
                flex: 1; /* 残りのスペースを占める */
            }
        }
    </style>
    <script>
        const csrfToken = "{{ form.csrf_token._value() }}";  // CSRFトークンをJavaScriptに渡す

        document.addEventListener('DOMContentLoaded', () => {
            const contentTextArea = document.getElementById('content');
            if (contentTextArea) {
                contentTextArea.dataset.initialLoad = 'true';
                contentTextArea.value = contentTextArea.value.replace(/\\n/g, '\n');
                
                if (contentTextArea.dataset.initialLoad === 'true') {
                    contentTextArea.focus();
                    contentTextArea.selectionStart = 0;
                    contentTextArea.selectionEnd = 0;
                    contentTextArea.scrollTop = 0;
                    delete contentTextArea.dataset.initialLoad;
                }
            }

            autoSaveContent();

            document.addEventListener('keydown', function(event) {
                if (event.ctrlKey && event.key === 'Enter') {
                    event.preventDefault();
                    const submitButton = document.querySelector('input[type="submit"]');
                    if (submitButton) {
                        submitButton.click();
                    }
                } else if (event.ctrlKey && event.key === 's') {
                    event.preventDefault();
                    saveWithoutRedirect();
                } else if (event.altKey && (event.code === 'KeyY' || event.key === 'y' || event.key === 'Y')) {
                    event.preventDefault();
                    const currentDate = getCurrentDate();
                    insertTextAtCursor(document.getElementById('content'), currentDate);
                } else if (event.altKey && (event.code === 'KeyH' || event.key === 'h' || event.key === 'H')) {
                    event.preventDefault();
                    const currentTime = getCurrentTime();
                    insertTextAtCursor(document.getElementById('content'), currentTime);
                } else if (event.altKey && (event.code === 'Digit1' || event.key === '1')) {
                    event.preventDefault();
                    cycleHeaderLevel(document.getElementById('content'));
                } else if (event.altKey && (event.code === 'Digit2' || event.key === '2')) {
                    event.preventDefault();
                    cycleDashMark(document.getElementById('content'));
                } else if (event.altKey && (event.code === 'Digit3' || event.key === '3')) {
                    event.preventDefault();
                    cycleNumberMark(document.getElementById('content'));
                } else if (event.altKey && (event.code === 'Digit4' || event.key === '4')) {
                    event.preventDefault();
                    cycleQuoteMark(document.getElementById('content'));
                } else if (event.altKey && event.key === 'ArrowUp') {
                    // ALT+Up: Move cursor to the beginning of the textarea
                    event.preventDefault();
                    const textarea = document.getElementById('content');
                    textarea.selectionStart = 0;
                    textarea.selectionEnd = 0;
                    textarea.focus();
                } else if (event.altKey && event.key === 'ArrowDown') {
                    // ALT+Down: Move cursor to the end of the textarea
                    event.preventDefault();
                    const textarea = document.getElementById('content');
                    textarea.selectionStart = textarea.value.length;
                    textarea.selectionEnd = textarea.value.length;
                    textarea.focus();
                }
            });

            const pasteMermaidButton = document.getElementById('pasteMermaidButton');
            if (pasteMermaidButton) {
                pasteMermaidButton.addEventListener('click', () => {
                    insertTextAtCursor(contentTextArea, '\n```mermaid\n\n```');
                });
            }

            // Markdown書式ボタン: トグル動作
            const insertHashButton = document.getElementById('insertHashButton');
            if (insertHashButton) {
                insertHashButton.addEventListener('click', () => {
                    cycleHeaderLevel(contentTextArea);
                });
            }

            const insertDashButton = document.getElementById('insertDashButton');
            if (insertDashButton) {
                insertDashButton.addEventListener('click', () => {
                    cycleDashMark(contentTextArea);
                });
            }

            const insert1Button = document.getElementById('insert1Button');
            if (insert1Button) {
                insert1Button.addEventListener('click', () => {
                    cycleNumberMark(contentTextArea);
                });
            }

            const insertQuoteButton = document.getElementById('insertQuoteButton');
            if (insertQuoteButton) {
                insertQuoteButton.addEventListener('click', () => {
                    cycleQuoteMark(contentTextArea);
                });
            }

            // その他のボタン: 従来通りの動作
            const insertSpaceButton = document.getElementById('insertSpaceButton');
            if (insertSpaceButton) {
                insertSpaceButton.addEventListener('click', () => {
                    insertTextAtLineStart(contentTextArea, ' ');
                });
            }

            const insertBoldButton = document.getElementById('insertBoldButton');
            if (insertBoldButton) {
                insertBoldButton.addEventListener('click', () => {
                    wrapSelectedTextWith(contentTextArea, '**');
                });
            }

            contentTextArea.addEventListener('paste', handlePaste);

            // LINEボタンの機能追加
            const lineButton = document.getElementById('lineButton');
            const overlay = document.getElementById('overlay');
            const lineTextInput = document.getElementById('lineTextInput');
            const lineAttachButton = document.getElementById('lineAttachButton');

            lineButton.addEventListener('click', () => {
                overlay.style.display = 'flex';
                lineTextInput.focus(); // オーバーレイが表示されたときにフォーカスを設定
            });

            let isComposing = false;

            lineTextInput.addEventListener('compositionstart', () => {
                isComposing = true;
            });

            lineTextInput.addEventListener('compositionend', () => {
                isComposing = false;
            });

            lineTextInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !isComposing) {
                    event.preventDefault();
                    const text = '\n' + lineTextInput.value;
                    insertTextAtCursor(contentTextArea, text);
                    lineTextInput.value = ''; // テキストボックスをクリア
                    lineTextInput.focus();
                }
            });

            lineAttachButton.addEventListener('click', () => {
                document.getElementById('uploadFileButton').click(); 
            });

            overlay.addEventListener('click', (event) => {
                if (event.target === overlay) {
                    overlay.style.display = 'none';
                }
            });

            // ESCキーが押されたときにオーバーレイを非表示にする
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    overlay.style.display = 'none';
                    if (document.getElementById('aiOverlay')) {
                        document.getElementById('aiOverlay').style.display = 'none';
                    }
                }
            });

            // YYボタンとHHボタンのイベントリスナーを追加
            const insertDateButton = document.getElementById('insertDateButton');
            const insertTimeButton = document.getElementById('insertTimeButton');

            if (insertDateButton) {
                insertDateButton.addEventListener('click', () => {
                    const currentDate = getCurrentDate();
                    insertTextAtCursor(contentTextArea, currentDate);
                });
            }

            if (insertTimeButton) {
                insertTimeButton.addEventListener('click', () => {
                    const currentTime = getCurrentTime();
                    insertTextAtCursor(contentTextArea, currentTime);
                });
            }

            // AI機能の実装（プリセット対応）
            const aiButton = document.getElementById('aiButton');
            const aiOverlay = document.getElementById('aiOverlay');
            const aiPromptInput = document.getElementById('aiPromptInput');
            const aiContextPreview = document.getElementById('aiContextPreview');
            const aiSendButton = document.getElementById('aiSendButton');
            const aiCancelButton = document.getElementById('aiCancelButton');
            const aiButtonText = document.getElementById('aiButtonText');
            const aiSpinner = document.getElementById('aiSpinner');
            const templateSelect = document.getElementById('templateSelect');
            const systemPromptSelect = document.getElementById('systemPromptSelect');

            let aiContextText = '';
            let aiCursorPosition = 0;
            let aiPresets = null;
            let selectedTemplateId = null;

            // AIプリセットを読み込む
            async function loadAIPresets() {
                try {
                    const response = await fetch('/ai_presets', {
                        headers: {
                            'X-CSRFToken': csrfToken
                        }
                    });
                    if (response.ok) {
                        aiPresets = await response.json();
                        renderTemplateSelect();
                        renderSystemPromptSelect();
                    } else {
                        console.error('Failed to load AI presets');
                    }
                } catch (error) {
                    console.error('Error loading AI presets:', error);
                }
            }

            // テンプレートドロップダウンを描画
            function renderTemplateSelect() {
                if (!aiPresets || !aiPresets.prompt_templates) return;

                templateSelect.innerHTML = '<option value="">-- テンプレートを選択 --</option>';

                Object.entries(aiPresets.prompt_templates).forEach(([id, template]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${template.icon} ${template.name}`;
                    templateSelect.appendChild(option);
                });
            }

            // テンプレート選択時の処理
            templateSelect.addEventListener('change', () => {
                const selectedId = templateSelect.value;
                if (selectedId && aiPresets.prompt_templates[selectedId]) {
                    selectedTemplateId = selectedId;
                    aiPromptInput.value = aiPresets.prompt_templates[selectedId].prompt;
                } else {
                    selectedTemplateId = null;
                    aiPromptInput.value = '';
                }
            });

            // システムプロンプトセレクトを描画
            function renderSystemPromptSelect() {
                if (!aiPresets || !aiPresets.system_prompts) return;

                systemPromptSelect.innerHTML = '';
                const selectedPromptId = aiPresets.user_presets?.selected_system_prompt || 'default';

                Object.entries(aiPresets.system_prompts).forEach(([id, prompt]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = prompt.name;
                    if (id === selectedPromptId) {
                        option.selected = true;
                    }
                    systemPromptSelect.appendChild(option);
                });
            }

            // システムプロンプトの選択変更を保存
            systemPromptSelect.addEventListener('change', async () => {
                const selectedId = systemPromptSelect.value;
                try {
                    await fetch('/ai_presets/system_prompt', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ preset_id: selectedId })
                    });
                } catch (error) {
                    console.error('Error saving system prompt:', error);
                }
            });

            // ページロード時にプリセットを読み込む
            loadAIPresets();

            // AIボタンクリック
            aiButton.addEventListener('click', () => {
                const start = contentTextArea.selectionStart;
                const end = contentTextArea.selectionEnd;
                const selectedText = contentTextArea.value.substring(start, end);

                if (selectedText) {
                    // テキスト選択時: コンテキストとして保存
                    aiContextText = selectedText;
                    aiCursorPosition = end; // 選択範囲の終わりにカーソルを設定
                    aiContextPreview.textContent = selectedText;
                    aiContextPreview.style.display = 'block';
                } else {
                    // 未選択時: コンテキストなし
                    aiContextText = '';
                    aiCursorPosition = start; // 現在のカーソル位置
                    aiContextPreview.style.display = 'none';
                }

                aiOverlay.style.display = 'flex';
                aiPromptInput.focus();
            });

            // AI送信ボタンクリック
            async function sendAIRequest() {
                let prompt = aiPromptInput.value.trim();

                // テンプレートが選択されていてプロンプト入力がない場合、テンプレートのプロンプトを使用
                if (selectedTemplateId && !prompt && aiPresets.prompt_templates[selectedTemplateId]) {
                    prompt = aiPresets.prompt_templates[selectedTemplateId].prompt;
                }

                if (!prompt) {
                    alert('テンプレートを選択するか、問い合わせ内容を入力してください');
                    return;
                }

                // ローディング状態に変更
                aiButtonText.style.display = 'none';
                aiSpinner.style.display = 'inline';
                aiSendButton.disabled = true;
                aiCancelButton.disabled = true;
                aiPromptInput.disabled = true;

                try {
                    const systemPromptId = systemPromptSelect.value;
                    const response = await fetch('/ai_assist', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            context: aiContextText,
                            system_prompt_id: systemPromptId
                        })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        // AI応答をテキストエリアに挿入
                        const aiResponse = data.response;
                        const insertText = '\n\n---\n( ・∀・)つ〃∩＜どうも！\n' + aiResponse + '\n---\n';

                        // カーソル位置に挿入
                        const value = contentTextArea.value;
                        contentTextArea.value = value.slice(0, aiCursorPosition) + insertText + value.slice(aiCursorPosition);

                        // カーソルを挿入後の位置に移動
                        const newPosition = aiCursorPosition + insertText.length;
                        contentTextArea.selectionStart = contentTextArea.selectionEnd = newPosition;
                        contentTextArea.focus();

                        // モーダルを閉じる
                        aiOverlay.style.display = 'none';

                        // リセット
                        selectedTemplateId = null;
                        aiPromptInput.value = '';
                        templateSelect.value = '';
                    } else {
                        alert('エラー: ' + (data.error || '不明なエラーが発生しました'));
                    }
                } catch (error) {
                    console.error('AI処理エラー:', error);
                    alert('AI処理に失敗しました: ' + error.message);
                } finally {
                    // ローディング状態を解除
                    aiButtonText.style.display = 'inline';
                    aiSpinner.style.display = 'none';
                    aiSendButton.disabled = false;
                    aiCancelButton.disabled = false;
                    aiPromptInput.disabled = false;
                }
            }

            aiSendButton.addEventListener('click', sendAIRequest);

            // AIキャンセルボタンクリック
            aiCancelButton.addEventListener('click', () => {
                aiOverlay.style.display = 'none';
                selectedTemplateId = null;
                aiPromptInput.value = '';
                templateSelect.value = '';
            });

            // AIオーバーレイクリック（背景クリック）
            aiOverlay.addEventListener('click', (event) => {
                if (event.target === aiOverlay) {
                    aiOverlay.style.display = 'none';
                    selectedTemplateId = null;
                    aiPromptInput.value = '';
                    templateSelect.value = '';
                }
            });

            // AIプロンプト入力でのIME制御
            let isAIComposing = false;
            aiPromptInput.addEventListener('compositionstart', () => {
                isAIComposing = true;
            });
            aiPromptInput.addEventListener('compositionend', () => {
                isAIComposing = false;
            });

            // AIプロンプト入力でのCtrl+Enter送信
            aiPromptInput.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key === 'Enter' && !isAIComposing) {
                    event.preventDefault();
                    sendAIRequest();
                }
            });

            // ========== プレビュー機能 ==========
            const previewToggleButton = document.getElementById('previewToggleButton');
            const previewPane = document.getElementById('previewPane');
            const resizer = document.getElementById('resizer');
            const editorContainer = document.querySelector('.editor-container');
            const editorPane = document.querySelector('.editor-pane');

            if (previewToggleButton && previewPane && resizer) {
                let previewVisible = false;

                // localStorageから前回の状態を復元
                const savedPreviewState = localStorage.getItem('previewVisible');
                if (savedPreviewState === 'true') {
                    previewVisible = true;
                }

                // Marked.js設定（post.htmlと同じ設定）
                const renderer = new marked.Renderer();

                renderer.code = function(code, language) {
                    const codeText = (typeof code === 'string' ? code : code.text).trim()
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    const lang = (language === undefined) ? code.lang : language;

                    if (lang === undefined) {
                        return `<pre>${codeText}</pre>`;
                    }

                    if (lang === 'mermaid') {
                        return `<div class="mermaid">${codeText}</div>`;
                    } else {
                        return `<pre><code>${codeText}</code></pre>`;
                    }
                };

                renderer.image = function(href, title, text) {
                    if (typeof href === 'object' && href !== null) {
                        href = href.href || 'default-image-path.jpg';
                    } else if (typeof href !== 'string') {
                        console.error('Invalid href:', href);
                        href = 'default-image-path.jpg';
                    }
                    text = text || 'image';
                    return `<img loading="lazy" src="${href}" alt="${text}">`;
                };

                marked.setOptions({
                    renderer: renderer,
                    sanitize: true
                });

                // テーブルのレンダリングをカスタマイズ
                const originalTable = renderer.table;
                renderer.table = function(header, body) {
                    const table = originalTable.call(this, header, body);
                    return '<div class="table-responsive">' + table + '</div>';
                };

                // Mermaid初期化
                mermaid.initialize({ startOnLoad: false });

                // プレビュー更新関数
                let updateTimeout;
                function updatePreview() {
                    clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(() => {
                        const markdown = contentTextArea.value;

                        // タイトルとタグを除外（3行目以降をプレビュー）
                        const lines = markdown.split('\n');
                        const contentOnly = lines.slice(2).join('\n');

                        try {
                            const html = marked.parse(contentOnly);

                            // 画面表示の際、以下のタグをエスケープ（post.htmlと同じ処理）
                            const tagsToEscape = ['title', 'script', 'style', 'iframe', 'object', 'embed', 'form', 'input', 'link', 'meta'];
                            let escapedHtml = html;
                            tagsToEscape.forEach(tag => {
                                const regex = new RegExp(`<${tag}>`, 'g');
                                const closingRegex = new RegExp(`</${tag}>`, 'g');
                                escapedHtml = escapedHtml.replace(regex, `&lt;${tag}&gt;`).replace(closingRegex, `&lt;/${tag}&gt;`);
                            });

                            // preview-content div に挿入（styles.cssの#contentスタイルを適用するため）
                            const previewContent = document.getElementById('preview-content');
                            previewContent.innerHTML = escapedHtml;

                            // Mermaidダイアグラムを再レンダリング
                            const mermaidElements = previewContent.querySelectorAll('.mermaid');
                            mermaidElements.forEach((element, index) => {
                                const id = `mermaid-${Date.now()}-${index}`;
                                mermaid.render(id, element.textContent).then(result => {
                                    element.innerHTML = result.svg;
                                }).catch(error => {
                                    console.error('Mermaid rendering error:', error);
                                    element.innerHTML = `<pre>Mermaid Error: ${error.message}</pre>`;
                                });
                            });
                        } catch (error) {
                            console.error('Markdown rendering error:', error);
                            const previewContent = document.getElementById('preview-content');
                            previewContent.innerHTML = '<p>Markdown rendering error</p>';
                        }
                    }, 300); // 300ms debounce
                }

                // プレビュートグルボタン
                previewToggleButton.addEventListener('click', () => {
                    previewVisible = !previewVisible;

                    // localStorageに状態を保存
                    localStorage.setItem('previewVisible', previewVisible);

                    if (previewVisible) {
                        previewPane.classList.remove('hidden');
                        editorContainer.classList.remove('preview-hidden');
                        editorPane.style.flex = '1';
                        previewPane.style.flex = '1';
                        updatePreview();
                    } else {
                        previewPane.classList.add('hidden');
                        editorContainer.classList.add('preview-hidden');
                    }
                });

                // リアルタイムプレビュー更新
                contentTextArea.addEventListener('input', () => {
                    if (previewVisible) {
                        updatePreview();
                    }
                });

                // localStorageの状態に基づいてプレビューを初期表示
                if (previewVisible) {
                    previewPane.classList.remove('hidden');
                    editorContainer.classList.remove('preview-hidden');
                    editorPane.style.flex = '1';
                    previewPane.style.flex = '1';
                    updatePreview();
                }

                // リサイザーのドラッグ機能
                let isResizing = false;
                let startX = 0;
                let startEditorWidth = 0;
                let startPreviewWidth = 0;

                resizer.addEventListener('mousedown', (e) => {
                    if (!previewVisible) return;

                    isResizing = true;
                    startX = e.clientX;
                    startEditorWidth = editorPane.offsetWidth;
                    startPreviewWidth = previewPane.offsetWidth;

                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';

                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;

                    const deltaX = e.clientX - startX;
                    const containerWidth = editorContainer.offsetWidth;
                    const resizerWidth = resizer.offsetWidth;

                    const newEditorWidth = startEditorWidth + deltaX;
                    const newPreviewWidth = startPreviewWidth - deltaX;

                    // 最小幅チェック（200px）
                    if (newEditorWidth >= 200 && newPreviewWidth >= 200) {
                        const editorFlex = newEditorWidth / (containerWidth - resizerWidth);
                        const previewFlex = newPreviewWidth / (containerWidth - resizerWidth);

                        editorPane.style.flex = editorFlex;
                        previewPane.style.flex = previewFlex;
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });
            }
        });

        function wrapSelectedTextWith(textArea, text) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;

            // 選択部分の前後にテキストを挿入
            if (text === '**') {
                //textArea.value = value.slice(0, start) + ' ' + text + value.slice(start, end) + text + ' ' + value.slice(end);
                textArea.value = value.slice(0, start) + text + value.slice(start, end) + text + value.slice(end);
                textArea.selectionStart = start + text.length; // 前後のスペースを考慮
                textArea.selectionEnd = end + text.length;
            } else {
                textArea.value = value.slice(0, start) + text + value.slice(start, end) + text + value.slice(end);
                textArea.selectionStart = start + text.length;
                textArea.selectionEnd = end + text.length;
            }
            textArea.focus();

            // カーソル位置までスクロール
            const cursorPosition = textArea.selectionStart;
            const lineHeight = parseInt(window.getComputedStyle(textArea).lineHeight);
            const scrollTop = textArea.scrollTop;
            const cursorY = Math.floor(cursorPosition / textArea.cols) * lineHeight;
            textArea.scrollTop = cursorY - (textArea.clientHeight / 2) + (lineHeight / 2);
        }

        function insertTextAtLineStart(textArea, text) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;

            const lineStart = value.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = value.indexOf('\n', end);
            const before = value.slice(0, lineStart);
            const after = value.slice(lineEnd === -1 ? value.length : lineEnd);

            const selectedLines = value.slice(lineStart, lineEnd === -1 ? value.length : lineEnd);
            const newText = selectedLines.split('\n').map(line => text + line).join('\n');

            textArea.value = before + newText + after;
            textArea.selectionStart = lineStart;
            textArea.selectionEnd = lineStart + newText.length;

            textArea.focus();
            console.log('Inserted Text at Line Start:', text);
        }

        function insertTextAtCursor(textArea, text) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;
            textArea.value = value.slice(0, start) + text + value.slice(start);
            textArea.selectionStart = textArea.selectionEnd = start + text.length;
            textArea.focus();

            // カーソル位置までスクロール
            const cursorPosition = textArea.selectionStart;
            const lineHeight = parseInt(window.getComputedStyle(textArea).lineHeight);
            const scrollTop = textArea.scrollTop;
            const cursorY = Math.floor(cursorPosition / textArea.cols) * lineHeight;
            textArea.scrollTop = cursorY - (textArea.clientHeight / 2) + (lineHeight / 2);
        }

        function getCurrentDate() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        }

        function getCurrentTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${hours}${minutes}${seconds}`;
        }

        async function handlePaste(event) {
            const items = (event.clipboardData || window.clipboardData).items;
            for (let item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        const formData = new FormData();
                        formData.append('file', file);

                        try {
                            const response = await fetch('/attach_upload', {
                                method: 'POST',
                                body: formData,
                                headers: {
                                    'X-CSRFToken': csrfToken  // CSRFトークンをヘッダーに追加
                                }
                            });

                            if (response.ok) {
                                const result = await response.json();
                                const smallImageUrl = result.url.replace(/\/([^\/]+)$/, '/s_$1');
                                const markdownLink = result.isImage 
                                    ? `[![${result.filename}](${smallImageUrl})](${result.url})` 
                                    : `[${result.filename}](${result.url})`;
                                console.log(markdownLink);
                                insertTextAtCursor(document.getElementById('content'), markdownLink);
                            } else {
                                alert('ファイルのアップロードに失敗しました。');
                            }
                        } catch (error) {
                            console.error('アップロード中にエラーが発生しました:', error);
                            alert('ファイルのアップロードに失敗しました。');
                        }
                    }
                    event.preventDefault();
                }
            }
        }

        async function saveWithoutRedirect() {
            const content = document.getElementById('content').value;
            const formData = new FormData();
            formData.append('content', content);

            try {
                const response = await fetch(window.location.href, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                if (response.ok) {
                    showTemporaryMessage('保存しました');
                } else {
                    showTemporaryMessage('保存に失敗しました');
                }
            } catch (error) {
                console.error('保存中にエラーが発生しました:', error);
                showTemporaryMessage('保存に失敗しました');
            }
        }

        function cycleHeaderLevel(textArea) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;

            // 選択範囲を含む行の開始と終了を取得
            const lineStart = value.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = value.indexOf('\n', end);
            const before = value.slice(0, lineStart);
            const after = value.slice(lineEnd === -1 ? value.length : lineEnd);

            // 選択範囲内の行を取得
            const selectedLines = value.slice(lineStart, lineEnd === -1 ? value.length : lineEnd);

            // 各行を独立してトグル
            const newText = selectedLines.split('\n').map(line => {
                // 現在の#の数を数える
                const match = line.match(/^#{1,3}\s/);
                let newPrefix = '';

                if (!match) {
                    newPrefix = '# '; // #なしから#へ
                } else {
                    const hashCount = match[0].trim().length;
                    if (hashCount < 3) {
                        newPrefix = '#'.repeat(hashCount + 1) + ' '; // 次のレベルへ
                    }
                    // hashCount === 3 の場合は newPrefix = '' のまま（#を削除）
                }

                // 既存の#を削除して新しい#を追加
                const lineWithoutHash = line.replace(/^#{1,3}\s/, '');
                return newPrefix + lineWithoutHash;
            }).join('\n');

            textArea.value = before + newText + after;
            textArea.selectionStart = lineStart;
            textArea.selectionEnd = lineStart + newText.length;
            textArea.focus();
        }

        function cycleDashMark(textArea) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;

            // 選択範囲を含む行の開始と終了を取得
            const lineStart = value.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = value.indexOf('\n', end);
            const before = value.slice(0, lineStart);
            const after = value.slice(lineEnd === -1 ? value.length : lineEnd);

            // 選択範囲内の行を取得
            const selectedLines = value.slice(lineStart, lineEnd === -1 ? value.length : lineEnd);

            // 各行を独立してトグル
            const newText = selectedLines.split('\n').map(line => {
                const hasDash = line.match(/^- /);
                return hasDash ? line.replace(/^- /, '') : '- ' + line;
            }).join('\n');

            textArea.value = before + newText + after;
            textArea.selectionStart = lineStart;
            textArea.selectionEnd = lineStart + newText.length;
            textArea.focus();
        }

        function cycleNumberMark(textArea) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;

            // 選択範囲を含む行の開始と終了を取得
            const lineStart = value.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = value.indexOf('\n', end);
            const before = value.slice(0, lineStart);
            const after = value.slice(lineEnd === -1 ? value.length : lineEnd);

            // 選択範囲内の行を取得
            const selectedLines = value.slice(lineStart, lineEnd === -1 ? value.length : lineEnd);

            // 各行を独立してトグル
            const newText = selectedLines.split('\n').map(line => {
                const hasNumber = line.match(/^1\. /);
                return hasNumber ? line.replace(/^1\. /, '') : '1. ' + line;
            }).join('\n');

            textArea.value = before + newText + after;
            textArea.selectionStart = lineStart;
            textArea.selectionEnd = lineStart + newText.length;
            textArea.focus();
        }

        function cycleQuoteMark(textArea) {
            if (!textArea) return;
            const start = textArea.selectionStart;
            const end = textArea.selectionEnd;
            const value = textArea.value;

            // 選択範囲を含む行の開始と終了を取得
            const lineStart = value.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = value.indexOf('\n', end);
            const before = value.slice(0, lineStart);
            const after = value.slice(lineEnd === -1 ? value.length : lineEnd);

            // 選択範囲内の行を取得
            const selectedLines = value.slice(lineStart, lineEnd === -1 ? value.length : lineEnd);

            // 各行を独立してトグル
            const newText = selectedLines.split('\n').map(line => {
                const hasQuote = line.match(/^> /);
                return hasQuote ? line.replace(/^> /, '') : '> ' + line;
            }).join('\n');

            textArea.value = before + newText + after;
            textArea.selectionStart = lineStart;
            textArea.selectionEnd = lineStart + newText.length;
            textArea.focus();
        }

    </script>
</head>
<body>

    <a href="/post" class="mb-2"><< post一覧へ</a>

    <form method="post" class="container" style="margin-left: 0px; margin-right: 0px; max-width: 100%">
        {{ form.hidden_tag() }} <!-- CSRFトークンを追加 -->
        <div class="btn-toolbar" role="toolbar" aria-label="Toolbar with button groups">
            <!-- グループ1: Markdown書式（使用頻度: 高） -->
            <div class="btn-group" role="group" aria-label="Markdown formatting">
                <button id="insertHashButton" type="button" class="btn btn-sm btn-outline-secondary" title="行の先頭に#を挿入">#</button>
                <button id="insertDashButton" type="button" class="btn btn-sm btn-outline-secondary" title="行の先頭に-を挿入">-</button>
                <button id="insert1Button" type="button" class="btn btn-sm btn-outline-secondary" title="行の先頭に1.を挿入">1.</button>
                <button id="insertQuoteButton" type="button" class="btn btn-sm btn-outline-secondary" title="行の先頭に>を挿入">&gt;</button>
                <button id="insertBoldButton" type="button" class="btn btn-sm btn-outline-secondary" title="選択したテキストを太字にする">B</button>
                <button id="insertSpaceButton" type="button" class="btn btn-sm btn-outline-secondary" title="行の先頭にスペースを挿入">Sp</button>
            </div>

            <!-- グループ2: ユーティリティ（使用頻度: 中） -->
            <div class="btn-group" role="group" aria-label="Utilities">
                <button type="button" class="btn btn-primary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false" title="挿入オプションを表示">
                    挿入
                </button>
                <ul class="dropdown-menu">
                    <li><button id="insertDateButton" type="button" class="dropdown-item" title="現在の日付を挿入">YYYYMMDD</button></li>
                    <li><button id="insertTimeButton" type="button" class="dropdown-item" title="現在の時刻を挿入">hhmmss</button></li>
                    <li><button id="uploadFileButton" type="button" class="dropdown-item" title="ファイルをアップロード">ファイル</button></li>
                    <li><button id="pasteMermaidButton" type="button" class="dropdown-item" title="Mermaid書式を挿入">Mermaid書式</button></li>
                </ul>
                <button id="lineButton" type="button" class="btn btn-primary" title="チャット入力モードを開く"><i class="fas fa-comment-dots"></i></button>
            </div>

            <!-- グループ3: 特殊機能（使用頻度: 中〜高） -->
            <button id="aiButton" type="button" class="btn btn-primary" title="AIアシスタント"><i class="fas fa-robot"></i></button>
            <button type="button" class="btn btn-primary" title="ページを閲覧" onclick="window.open('{{ url_for('post', filename=request.view_args['filename']) }}', '_blank')">
                <i class="fas fa-external-link-alt"></i>
            </button>
            <button id="previewToggleButton" type="button" class="btn btn-primary preview-toggle" title="プレビューを表示/非表示">
                <i class="fas fa-columns"></i>
            </button>
        </div>
        <input type="file" id="fileInput" style="display:none;">

        行1:タイトル(#限定公開、##非公開)　行2:タグ
        <div class="editor-container">
            <div class="editor-pane">
                <textarea id="content" name="content" class="form-control" rows="10">{{ content|safe }}</textarea>
            </div>
            <div class="resizer" id="resizer"></div>
            <div class="preview-pane main-content hidden" id="previewPane">
                <div id="preview-content"></div>
            </div>
        </div>
        <input type="submit" value="Save" class="btn btn-success mt-2 btn-block">
    </form>

    <div id="overlay" class="overlay">
        <div class="dialog">
            チャット入力モード
            <input type="text" id="lineTextInput" class="form-control" placeholder="Enter text">
            <button id="lineAttachButton" class="btn btn-secondary">
                <i class="fas fa-paperclip"></i>
            </button>
        </div>
    </div>

    <!-- AIモーダル（2タブ構成） -->
    <div id="aiOverlay" class="overlay">
        <div class="dialog ai-dialog">
            <h5>AIアシスタント</h5>

            <!-- タブナビゲーション -->
            <ul class="nav nav-tabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="template-tab" data-bs-toggle="tab" data-bs-target="#template-panel" type="button" role="tab">テンプレート</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="settings-tab" data-bs-toggle="tab" data-bs-target="#settings-panel" type="button" role="tab">設定</button>
                </li>
            </ul>

            <!-- タブコンテンツ -->
            <div class="tab-content" style="margin-top: 10px;">
                <!-- テンプレートタブ -->
                <div class="tab-pane fade show active" id="template-panel" role="tabpanel">
                    <div id="aiContextPreview" class="ai-context-preview" style="display:none;"></div>

                    <!-- プロンプトテンプレート選択 -->
                    <div class="mb-3">
                        <label for="templateSelect" class="form-label">テンプレート</label>
                        <select id="templateSelect" class="form-select">
                            <option value="">-- テンプレートを選択 --</option>
                            <!-- JavaScriptで動的に生成 -->
                        </select>
                    </div>

                    <!-- 追加指示入力欄 -->
                    <textarea id="aiPromptInput" class="form-control" rows="3" placeholder="追加の指示があればこちらに入力してください（Ctrl+Enterで送信）"></textarea>

                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="aiSendButton" class="btn btn-primary" style="flex: 1;">
                            <span id="aiButtonText">送信</span>
                            <span id="aiSpinner" style="display: none;">
                                <i class="fas fa-spinner fa-spin"></i> 処理中...
                            </span>
                        </button>
                        <button id="aiCancelButton" class="btn btn-secondary">キャンセル</button>
                    </div>
                </div>

                <!-- 設定タブ -->
                <div class="tab-pane fade" id="settings-panel" role="tabpanel">
                    <div style="margin-top: 10px;">
                        <label for="systemPromptSelect" class="form-label">システムプロンプト</label>
                        <select id="systemPromptSelect" class="form-select">
                            <!-- JavaScriptで動的に生成 -->
                        </select>
                        <div class="form-text">AIの振る舞いを設定できます</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/static/jquery-3.7.0.min.js"></script>
    <script src="/static/popper.min.js"></script>
    <script src="/static/bootstrap.min.js"></script>
    <script src="/static/scripts.js"></script>
    <script src="/static/upload.js"></script>

    <!-- Markdown rendering libraries for preview -->
    <script src="/static/marked.min.js"></script>
    <script src="/static/mermaid.min.js"></script>

</body>
</html>